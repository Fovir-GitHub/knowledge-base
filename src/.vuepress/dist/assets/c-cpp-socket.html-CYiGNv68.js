import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,b as n,r as d,o as l}from"./app-BGTZnLUV.js";const h={};function r(o,s){const e=d("Mermaid");return l(),t("div",null,[s[0]||(s[0]=i('<h2 id="background" tabindex="-1"><a class="header-anchor" href="#background"><span>Background</span></a></h2><p>The &quot;Build your own HTTP server&quot; challenge on <a href="https://app.codecrafters.io/catalog" target="_blank" rel="noopener noreferrer">CodeCrafters</a> is free in this month, so I took this challenge and learned the usage of <code>socket</code>. This note was born for documenting my understanding of <code>socket</code> library.</p><p>In this note, I will use <code>C++</code> to demonstrate the code although <code>socket</code> is a library in <code>C</code> programming language.</p><h2 id="what-is-socket" tabindex="-1"><a class="header-anchor" href="#what-is-socket"><span>What is <code>socket</code>?</span></a></h2><p><code>socket</code> is used to implement <code>TCP</code> or <code>UDP</code> connections. It can also be used to implement an <code>HTTP</code> connection, since <code>HTTP</code> is based on <code>TCP</code>. In addition, the developers can treat a socket as a file descriptor or a <code>FILE</code> pointer in <code>C</code> programming language, using it to read from and write to network connection like regular files.</p><h2 id="server-side-socket-operation" tabindex="-1"><a class="header-anchor" href="#server-side-socket-operation"><span>Server-Side <code>socket</code> Operation</span></a></h2><p>The working process of server-side <code>socket</code> is demonstrated in the following flowchart.</p>',7)),n(e,{id:"mermaid-21",code:"eJxlUMGOQjEIvPsVxNPuwV/YZNWjJ/XWeEBEbXyWpiX6+/LAqIlNChNmKExPDesZtssJ2KHGqJwWngChC11Y4ZgHhgN3armqtJ1rO6tUzVLSdGOapzRKHX4C4PA7Dfk+l0OaWwAcL1RpGsyQu3JJK0+gZ3bOZXfMNl0akJTC5E9HExJx1fTvyZveEjg2uQINmctzRGO6pTUT55sZQcVvSWfbb2MheJUX+/Ezs9nfy7bh0ZOlMGAgljIwznOt81GePABfg3qt"}),s[1]||(s[1]=i(`<h2 id="header-files" tabindex="-1"><a class="header-anchor" href="#header-files"><span>Header Files</span></a></h2><p>After knowing the working process, it is time to explore which header files can be used. In this part, I will introduce the header files and their functions, structures and so on separately.</p><h3 id="arpa-inet-h-netinet-in-h" tabindex="-1"><a class="header-anchor" href="#arpa-inet-h-netinet-in-h"><span><code>&lt;arpa/inet.h&gt;</code> &amp; <code>&lt;netinet/in.h&gt;</code></span></a></h3><p>The structure <code>sockaddr_in</code> stores the connection information. Its definition is below and I only show the staple members.</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint16_t</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in_port_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sockaddr_in</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    sa_family_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sin_family;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    in_port_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sin_port;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> in_addr sin_addr;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>in_addr</code> is defined as:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32_t</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in_addr_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> in_addr</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    in_addr_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s_addr;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><em>in</em> stands for <em>internet</em></p></blockquote><p>To assign a value to <code>sockaddr_in.sin_port</code>, we can use <code>uint16_t htons(uint16_t hostshort)</code> to convert an integer into the <code>uint16_t</code> instead of assigning the value directly. One way to use is like:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">sockaddr_in server_address;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">server_address</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sin_port</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> htons</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4221</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If we want the socket listen to a specific IP, we can use <code>int inet_pton(int af, const char * cp, void * buf)</code> to assign the IP address to the <code>sockaddr_in.sin_addr</code>. One way to use is:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">inet_pton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(AF_INET, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;127.0.0.1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">server_address</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sin_addr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Plus, the server should listen to all address <code>0.0.0.0</code> sometimes, and we can assign the macro <code>INADDR_ANY</code> to <code>sockaddr_in.sin_addr.s_addr</code> so the server could listen to any address.</p><h3 id="sys-socket-h" tabindex="-1"><a class="header-anchor" href="#sys-socket-h"><span><code>&lt;sys/socket.h&gt;</code></span></a></h3><p>This header file offers the following useful functions:</p><ul><li><code>int socket(int domain, int type, int protocol)</code></li><li><code>int setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen)</code></li><li><code>int bind(int fd, const sockaddr * addr, socklen_t len)</code></li><li><code>int listen(int fd, int n)</code></li><li><code>int accept(int fd, sockaddr * addr, socklen_t * addr_len)</code></li><li><code>ssize_t recv(int fd, void * buf, size_t n, int flags)</code></li><li><code>ssize_t send(int fd, const void * buf, size_t n, int flags)</code></li></ul><p>The <code>sockaddr</code> is a structure in <code>&lt;bits/socket.h&gt;</code> header file, and also the short name of <em>socket address</em>. The definition is</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sockaddr</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    sa_family_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sa_family;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sa_data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">14</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <em>sa</em> prefix stands for <em>sockaddr</em>.</p><p>Now let&#39;s take a look at each functions above.</p><h4 id="int-socket-int-domain-int-type-int-protocol" tabindex="-1"><a class="header-anchor" href="#int-socket-int-domain-int-type-int-protocol"><span><code>int socket(int domain, int type, int protocol)</code></span></a></h4><p>This function accepts three arguments, which are</p><table><thead><tr><th>Argument</th><th>Meaning</th><th>Possible Value</th></tr></thead><tbody><tr><td><code>domain</code></td><td>The address family</td><td><code>AF_INET</code>, <code>AF_INET6</code></td></tr><tr><td><code>type</code></td><td>The type of sockets</td><td><code>SOCK_STREAM</code>, <code>SOCK_RAW</code></td></tr><tr><td><code>protocol</code></td><td>The protocol of the socket</td><td><code>0</code> (Automatically select), <code>IPPROTO_TCP</code>, <code>IPPROTO_UDP</code></td></tr></tbody></table><blockquote><p>The <em>AF</em> stands for *Address Family\`.</p></blockquote><p>And it will return a descriptor of the socket.</p><p>The code below is a common way to create a <code>TCP</code> socket server.</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> server_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(AF_INET, SOCK_STREAM, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Where <em>fd</em> stands for <em>file descriptor</em>.</p><p>After creating a file descriptor of the server, it is optional to do some settings, which needs to call <code>setsockopt()</code> function.</p><h4 id="int-setsockopt-int-fd-int-level-int-optname-const-void-optval-socklen-t-optlen" tabindex="-1"><a class="header-anchor" href="#int-setsockopt-int-fd-int-level-int-optname-const-void-optval-socklen-t-optlen"><span><code>int setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen)</code></span></a></h4><p>The first argument <code>fd</code> is the file descriptor, which is <code>server_fd</code> in this example.</p><p>The <code>level</code> defines the level of protocol. Usually we use <code>SOL_SOCKET</code> macro which is defined in <code>socket.h</code> header file. There are also some other options like <code>IPPROTO_TCP</code>, <code>IPPROTO_IP</code> and so on.</p><p>The third argument <code>optname</code> accepts the options. There are a lot of available options in <code>socket.h</code> file, for example, <code>SO_DEBUG</code>, <code>SO_REUSEADDR</code>, etc.</p><p>The remaining value is used to set whether enable or disable the options. If we want to enable the <code>SO_REUSEADDR</code> options, the code is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> reuse </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setsockopt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">reuse, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(reuse));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If the function failed, it will return <code>-1</code>. Otherwise, it will return <code>0</code>.</p><p>After setting the socket, we can bind the socket to specific address by using <code>bind()</code> function.</p><h4 id="int-bind-int-fd-const-sockaddr-addr-socklen-t-len" tabindex="-1"><a class="header-anchor" href="#int-bind-int-fd-const-sockaddr-addr-socklen-t-len"><span><code>int bind(int fd, const sockaddr * addr, socklen_t len)</code></span></a></h4><p>The first argument determines which server file descriptor to bind.</p><p>The second argument stands for the address we want to bind and the type of it is <code>const sockaddr *</code>, however, what we define previous is <code>sockaddr_in server_address</code>. So it needs a type cast here.</p><p>The last argument is the length of the address, which can gain by just using <code>sizeof(server_address)</code>.</p><p>The common usage is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(server_fd, </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">reinterpret_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">sockaddr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">server_address), </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(server_address));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>If the <code>bind()</code> failed, it will return <code>-1</code>. Otherwise, it will return <code>0</code> instead.</p><p>By the flowchart above, the next stage is to listen to the client connections, which needs <code>listen()</code> function.</p><h4 id="int-listen-int-fd-int-n" tabindex="-1"><a class="header-anchor" href="#int-listen-int-fd-int-n"><span><code>int listen(int fd, int n)</code></span></a></h4><p>This function is easier than previous functions since it has only two arguments.</p><p>The first one is the file descriptor of the server.</p><p>The second one determines the maximum connections can be queued.</p><p>If we want the server to listen to the address with maximum 5 connections queuing, the statement is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">listen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(server_fd, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Same as the functions before, it will return <code>-1</code> if it failed and return <code>0</code> if it succeeded.</p><h4 id="int-accept-int-fd-sockaddr-addr-socklen-t-addr-len" tabindex="-1"><a class="header-anchor" href="#int-accept-int-fd-sockaddr-addr-socklen-t-addr-len"><span><code>int accept(int fd, sockaddr * addr, socklen_t * addr_len)</code></span></a></h4><p>This function is used to get the client&#39;s address and the file descriptor of the client.</p><p>The first argument is the file descriptor of the server.</p><p>The second argument is the address of client.</p><p>And the third argument is the length of client address.</p><p>It will return a non-negative integer to stand for the file descriptor of the client. It will return negative integer once it failed.</p><p>One simple way to use it is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">sockaddr_in client_address;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      client_address_length </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(client_address);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">         client_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(server_fd, </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">reinterpret_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">sockaddr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">client_address),</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">            reinterpret_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">socklen_t</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">client_address_length));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After gaining the file descriptor of client, it means we can treat it as regular files. In this example, we only show how to receive and send data.</p><h4 id="ssize-t-recv-int-fd-void-buf-size-t-n-int-flags" tabindex="-1"><a class="header-anchor" href="#ssize-t-recv-int-fd-void-buf-size-t-n-int-flags"><span><code>ssize_t recv(int fd, void * buf, size_t n, int flags)</code></span></a></h4><p>This function is used to receive data from <code>fd</code>. If we want to receive the data from the client, we can set it to <code>client_fd</code> which has gotten before.</p><p>The second argument accepts a buffer to store the received data. Usually we use a string to store the data.</p><p>The third argument is the size or the length of the buffer.</p><p>The last argument <code>flags</code> is used to control the behavior of receiving. By default, we can set it to <code>0</code>. There are also some other options which is defined in <code>&lt;bits/socket.h&gt;</code> in macro form.</p><p>If the function failed, it will return <code>-1</code>. And if it succeeded, it will return the size of received data.</p><p>One example is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> BUFFER_SIZE </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BUFFER_SIZE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ssize_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> receive_bytes </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> recv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(client_fd, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], BUFFER_SIZE, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(receive_bytes);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="ssize-t-send-int-fd-const-void-buf-size-t-n-int-flags" tabindex="-1"><a class="header-anchor" href="#ssize-t-send-int-fd-const-void-buf-size-t-n-int-flags"><span><code>ssize_t send(int fd, const void * buf, size_t n, int flags)</code></span></a></h4><p>This function is used to send data to the <code>fd</code>. If we want to send data to the client, we can set it to <code>client_fd</code>.</p><p>The second argument is the buffer which stores the data to be sent.</p><p>The third one is the size or length of the buffer.</p><p>Same to the <code>recv()</code> function, the last argument <code>flags</code> controls the behavior of sending data.</p><p>The return value is the size of data that is sent successfully. If it failed, the return value will be <code>-1</code>.</p><p>One example is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string response </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;The server accepted the request</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(client_fd, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">response</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">c_str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">response</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If the connection is closed, and the file descriptor is no longer used, we should use <code>close()</code> function which is defined in <code>&lt;unistd.h&gt;</code> header file, to close it.</p><p>The usage is</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(client_fd);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><blockquote><p>Reference</p><p><a href="https://app.codecrafters.io/" target="_blank" rel="noopener noreferrer">CodeCrafters</a></p></blockquote>`,82))])}const k=a(h,[["render",r]]),g=JSON.parse('{"path":"/network/socket/c-cpp-socket.html","title":"Socket in C/C++","lang":"en-US","frontmatter":{"date":"2025-04-09T00:00:00.000Z","title":"Socket in C/C++","description":"This note documents how to use `socket` in `C/C++`.","icon":"streamline-logos:c-plus-language-logo-solid","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Socket in C/C++\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-09T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T15:28:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Fovir\\",\\"url\\":\\"https://fovir.fyi\\"}]}"],["meta",{"property":"og:url","content":"https://fovir.fyi/network/socket/c-cpp-socket.html"}],["meta",{"property":"og:site_name","content":"Fovir\'s Knowledge Base"}],["meta",{"property":"og:title","content":"Socket in C/C++"}],["meta",{"property":"og:description","content":"This note documents how to use `socket` in `C/C++`."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-06-06T15:28:09.000Z"}],["meta",{"property":"article:published_time","content":"2025-04-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T15:28:09.000Z"}]]},"git":{"createdTime":1749220645000,"updatedTime":1749223689000,"contributors":[{"name":"Fovir","username":"","email":"fovir@disroot.org","commits":2}]},"readingTime":{"minutes":4.71,"words":1414},"filePathRelative":"network/socket/c-cpp-socket.md"}');export{k as comp,g as data};
